# システム設計書 (v2.0)

## 1. 設計思想とコンセプト (Design Philosophy and Concept)

このドキュメントは、AIタスク管理アプリケーションの技術的な仕様だけでなく、その背景にある設計思想や意思決定のプロセスを記録することを目的とします。これにより、将来の機能追加やメンテナンス、そして私（Gemini）との対話を再開する際の文脈の復元を容易にします。

### 1.1. 基本方針: 迅速なプロトタイピングと段階的成長

*   **なぜこの技術スタックか？**: `React`, `Node.js (Express)`, `PostgreSQL` という組み合わせは、Web開発において非常に標準的で、豊富なドキュメントとエコシステムを持っています。これにより、複雑な設定に時間を費やすことなく、迅速に価値あるプロトタイプを構築することを目指しました。`Docker`の採用も同様に、開発環境の構築をコマンド一発で完了させ、誰でもすぐに開発に参加できることを意図しています。

*   **なぜインライン編集なのか？**: 一般的なWebフォーム（入力画面 → 確認画面 → 完了画面）は、タスク管理のように頻繁に小さな更新が発生するユースケースでは煩雑です。スプレッドシートのように、ユーザーが見ているその場で直接データを書き換えられる**インライン編集**方式を採用することで、クリック数を減らし、思考を中断させないスムーズなUXを提供することを最優先としました。

### 1.2. 意図的な技術的負債と将来の展望

*   **なぜ密結合を許容したか？**: 現在の設計では、特にデータベーススキーマとフロントエンドの型定義が密結合しています（詳細は後述）。これは、開発速度を優先した結果の**意図的な技術的負債**です。小規模なプロトタイプの段階では、スキーマ定義からコードを自動生成するようなツール（例: OpenAPI, GraphQL）を導入するコストよりも、手動で同期を取る方が早いと判断しました。しかし、このドキュメントではそのリスクを明確に記録し、将来プロジェクトが成長する際には、これらのツールの導入を検討すべきであることを示唆しています。

## 2. システム概要 (System Overview)

タスクの進捗管理を行うための、シングルページアプリケーション（SPA）です。主な機能として、タスクの一覧表示、インラインでのタスク編集、新規タスクの追加、複数タスクの一括削除、テーブルヘッダーのラベル編集機能を提供します。

## 3. アーキテクチャ (Architecture)

実績のある標準的な3層アーキテクチャを採用しています。

```mermaid
graph TD
    A["フロントエンド (React/TypeScript)"] --> B("バックエンド (Node.js/Express)");
    B --> C[("データベース")]
```

*   **フロントエンド**: ユーザーとの全インタラクションを担います。`Vite`による高速な開発サーバーでビルドされます。
*   **バックエンド**: フロントエンドからのリクエストに応じてビジネスロジックを実行する、ステートレスなAPIサーバーです。
*   **データベース**: `PostgreSQL`を使用。すべての永続データを管理します。

## 4. フロントエンド (frontend)

### 4.1. 使用技術

*   **フレームワーク**: React 19.1.0
*   **言語**: TypeScript
*   **ビルドツール**: Vite
*   **スタイリング**: styled-components
*   **パッケージ管理**: npm

### 4.2. 状態管理とデータフロー

*   **状態管理の考え方**: この規模のアプリケーションでは、`Redux`のような外部の状態管理ライブラリは過剰と判断し、React標準の`useState`, `useCallback`フックによるシンプルなコンポーネントローカルな状態管理を採用しました。
*   **データフロー**: データは常に親コンポーネント (`App.tsx`) から子コンポーネント (`TaskList`, `TaskItem`) へ単一方向に流れます（トップダウン）。これにより、データの流れが予測しやすくなり、デバッグが容易になります。

### 4.3. コンポーネントの責務分担 (Atomic Design)

コンポーネントは、再利用性と管理のしやすさを向上させるため、Atomic Designの原則に基づいて以下のディレクトリ構造で管理します。

-   `src/components/atoms`: ボタン、インプット、ラベルなど、それ以上分割できない最小単位のUIコンポーネント。
-   `src/components/molecules`: 複数のAtomを組み合わせて作られた、意味を持つUI部品（例: 検索フォーム、タスク一行）。
-   `src/components/organisms`: 複数のMoleculeやAtomを組み合わせて作られた、自己完結したUIのセクション（例: タスク一覧テーブル全体）。
-   `src/pages`: アプリケーションの各ページを構成するコンポーネント。Organismを組み合わせてレイアウトを定義します。

#### Pages

-   **`TaskManagementPage.tsx`**
    -   **責務**: アプリケーション全体の状態（タスク一覧、ヘッダー一覧、選択中のタスクID、ローディング状態など）をすべて保持する、唯一の状態管理コンポーネントです。
    -   **役割**: バックエンドとのAPI通信をすべて担当し、その結果を自身のstateとして保持します。タスクの追加・更新・削除といったロジック（イベントハンドラ）もここで定義し、子コンポーネントには関数としてpropsで渡します。

#### Organisms

-   **`PageHeader.tsx`**: ページ上部に表示されるヘッダー。アプリケーションのタイトルを表示します。
-   **`TaskList.tsx`**
    -   **責務**: `TaskManagementPage.tsx`から受け取ったタスクとヘッダーのデータをレイアウトし、テーブルとして表示することに専念します。
    -   **役割**: 自身ではAPI通信を行いません。ユーザーのアクション（ボタンクリックなど）が発生すると、propsで渡された`TaskManagementPage.tsx`の関数を呼び出すだけです。ヘッダーラベルのインライン編集に関する一時的なUI状態のみ、自身のstateで管理します。

#### Molecules

-   **`TaskItem.tsx`**
    -   **責務**: 1つのタスク行の表示と、その行内での編集機能に専念します。
    -   **役割**: propsで渡された1つのタスク情報を基に、各セルを描画します。入力が行われると、自身のstate (`editingTask`) を一時的に更新し、入力が完了（`onBlur`イベント）した時点で、propsで渡された`onUpdateTask`関数を呼び出して、親コンポーネントに変更を通知します。

#### Atoms

-   **`Button.tsx`**: アプリケーション全体で使われるボタンのスタイルを定義します。
-   **`Input.tsx`**: テキストや数値の入力フィールドのスタイルを定義します。
-   **`Select.tsx`**: ドロップダウン選択メニューのスタイルを定義します。

### 4.4. UI/UXデザイン方針

アプリケーション全体のUI/UXは、以下のデザインシステムに基づいて設計します。これにより、一貫性、予測可能性、そして美しさを実現します。

#### 1. カラーパレット (Color Palette)

色は、ユーザーの注意を引きつけ、情報を伝達し、アクションを促すための重要な要素です。

*   **Primary (プライマリー)**
    *   `#4472C4` (濃い青): 主要なアクション、ヘッダー、フォーカス時のインジケーターなど、最も目立たせたい要素に使用します。
    *   使用例: ページヘッダー、テーブルヘッダー
*   **Secondary (セカンダリー)**
    *   `#E9ECEF` (グレー): 補足的な情報や、非アクティブな状態を示すために使用します。
    *   使用例: 通常のボタンの枠線、プレースホルダーテキスト
*   **Text (テキスト)**
    *   `#5F5F5F` (ほぼ黒): 基本となるテキストカラー。高い可読性を確保します。
    *   `#FFFFFF` (白): 濃い色の背景（プライマリーカラーなど）の上で使用します。
*   **その他強調色**
    *   `#e9b000` (黄) :　プライマリーカラーほどではないが、強調表示すべき情報に割り当てたい色（例： 進行中のタスク）
    *   `#70AD47` (緑) :  ポジティブな印象を与えたい箇所を強調表示する色（例： 完了したタスク）

#### 2. タイポグラフィ (Typography)

フォントのサイズとウェイトは、情報の階層を明確にし、読みやすさを向上させます。

*   **基本フォントサイズ**: `8x` (これを`1rem`の基準とします)
*   **見出し (Header)**
    *   `h1`: `1.5rem` (12px), `font-weight: 500` - ページのメインタイトル
*   **テーブル (Table)**
    *   ヘッダー: `1rem` (8px), `font-weight: 600`
    *   ボディ: `1rem` (8px), `font-weight: 400`
*   **ボタン (Button)**
    *   `0.8rem` (6.5px), `font-weight: 500`

## 5. バックエンド (backend)

### 5.1. 使用技術

*   **フレームワーク**: Express 4.17.1
*   **言語**: JavaScript (Node.js)
*   **データベースクライアント**: pg 8.7.1
*   **ID生成**: uuid

### 5.2. APIエンドポイント詳細

*   `GET /api/tasks`: 全タスクを取得。単純なSELECT文で全件を返す。
*   `POST /api/tasks`: 新規タスクを作成。IDをサーバーサイドで生成し、固定の初期値（タイトル: 'New Task', ステータス: 'Todo'）でレコードを挿入後、作成されたレコードを返す。
*   `PUT /api/tasks/:id`: 既存タスクを更新。リクエストボディで受け取った全項目でレコードを上書きする。
*   `POST /api/tasks/delete`: 複数タスクを削除。リクエストボディのID配列 (`ids`) を使い、`DELETE ... WHERE id = ANY($1)` 構文で効率的に一括削除する。
*   `GET /api/headers`: 全ヘッダー定義を取得。
*   `PUT /api/headers/:id`: ヘッダーラベルを更新。

## 6. データベース (db)

### 6.1. テーブル設計の意図

*   **`tasks`**: タスク管理のコアとなるテーブル。`planned_effort`（予定工数）と`actual_effort`（実績工数）を分けることで、予実管理を可能にするなど、基本的な拡張性を持たせています。
*   **`table_headers`**: なぜこのテーブルが必要か？当初はフロントエンドにヘッダーをハードコーディングしていましたが、ユーザーがラベルを自由に変更できる機能の要望に応えるため、ヘッダー定義をDBで管理する方式に変更しました。`column_key`がプログラム上のキー、`label`が表示用の文字列という役割分担です。

### 6.2. テーブルスキーマ

*   **tasks**
    ```sql
    CREATE TABLE tasks (
        id VARCHAR(255) PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        status VARCHAR(255) NOT NULL,
        assignee VARCHAR(255),
        planned_start_date DATE,
        planned_effort INT,
        actual_effort INT
    );
    ```
*   **table_headers**
    ```sql
    CREATE TABLE table_headers (
        id SERIAL PRIMARY KEY,
        column_key VARCHAR(255) UNIQUE NOT NULL,
        label VARCHAR(255) NOT NULL
    );
    ```

## 7. インフラストラクチャと運用

*   **`docker-compose.yml`**: `db`と`backend`サービスを定義。フロントエンドは、Viteの開発サーバーがHMR（ホットリロード）を提供するため、コンテナ化せずローカルで直接実行する方が開発効率が高いと判断しました。
*   **`restart: always`**: 開発中に予期せぬエラーでコンテナが停止しても自動で復旧し、開発体験を損なわないように設定しています。
*   **DBデータリセット手順**: DBスキーマ (`init.sql`) を変更した際、既存のデータボリューム (`./db-data`) があると変更が反映されない問題がありました。これは、`docker-compose down`後に`./db-data`を手動で削除し、`docker-compose up --build`で再起動することで解決しました。この手順は、スキーマ変更時に必須となります。

## 8. 既知の課題と将来の改善案 (密結合について)

(このセクションの内容は、前回の記述が的確であるため、ほぼそのまま維持します)

現在のアーキテクチャには、開発速度を優先した結果、いくつかの密結合な箇所が存在します。

### 8.1. 【最重要課題】DBスキーマとフロントエンドの型定義の乖離リスク

*   **問題**: DBスキーマの変更が、APIのレスポンス、そしてフロントエンドのTypeScript型定義 (`types.ts`) に**自動的に伝播しません**。これらはすべて開発者が**手動で**一貫性を保つ必要があり、変更箇所を一つでも忘れるとバグの温床となります。
*   **具体例**: `tasks`テーブルに`priority`カラムを追加した場合、`init.sql`, `server.js` (SELECT, UPDATE文), `types.ts` の3箇所すべてを忘れずに修正する必要があります。

### 8.2. 将来的な改善策

この密結合を解消し、システムの堅牢性を高めるため、プロジェクトの成長に合わせて以下の導入を検討すべきです。

*   **スキーマ駆動開発**: **OpenAPI**や**GraphQL**を導入し、スキーマ定義を信頼できる唯一の情報源 (Single Source of Truth) とします。これにより、サーバーとクライアントのコード（特に型定義）を自動生成し、手動での同期作業を撲滅します。
*   **O/Rマッパー (ORM)**: **Prisma**のようなモダンなORMを導入することで、DBスキーマから型安全なデータベースクライアントを生成し、バックエンドコード内でのタイプミスやスキーマとの不整合を防ぎます。